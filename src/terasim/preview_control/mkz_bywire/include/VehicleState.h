// Generated by gencpp from file mcity_msg/VehicleState.msg
// DO NOT EDIT!


#ifndef MCITY_MSG_MESSAGE_VEHICLESTATE_H
#define MCITY_MSG_MESSAGE_VEHICLESTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mcity_msg
{
template <class ContainerAllocator>
struct VehicleState_
{
  typedef VehicleState_<ContainerAllocator> Type;

  VehicleState_()
    : timestamp(0.0)
    , RTK_state_string()
    , RTK_seq_num(0)
    , RTK_timestamp_sec(0)
    , RTK_timestamp_nsec(0)
    , RTK_gps_status(0)
    , RTK_gps_service(0)
    , RTK_gps_longitude(0.0)
    , RTK_gps_latitude(0.0)
    , RTK_gps_altitude(0.0)
    , RTK_gps_UTM_x(0.0)
    , RTK_gps_UTM_y(0.0)
    , RTK_gps_UTM_z(0.0)
    , RTK_imu_quaternion_x(0.0)
    , RTK_imu_quaternion_y(0.0)
    , RTK_imu_quaternion_z(0.0)
    , RTK_imu_quaternion_w(0.0)
    , RTK_heading(0.0)
    , RTK_attitude(0.0)
    , RTK_bank(0.0)
    , RTK_linear_ENU_vx(0.0)
    , RTK_linear_ENU_vy(0.0)
    , RTK_linear_ENU_vz(0.0)
    , RTK_gps_twist_linear_vx(0.0)
    , RTK_gps_twist_linear_vy(0.0)
    , RTK_gps_twist_linear_vz(0.0)
    , RTK_imu_linear_acc_x(0.0)
    , RTK_imu_linear_acc_y(0.0)
    , RTK_imu_linear_acc_z(0.0)
    , RTK_gps_twist_angular_vx(0.0)
    , RTK_gps_twist_angular_vy(0.0)
    , RTK_gps_twist_angular_vz(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , speed_x(0.0)
    , speed_y(0.0)
    , speed_z(0.0)
    , acc_x(0.0)
    , acc_y(0.0)
    , acc_z(0.0)
    , heading(0.0)
    , yaw_rate(0.0)
    , by_wire_enabled(false)
    , throttle_cmd(0.0)
    , throttle_input(0.0)
    , throttle_state(0.0)
    , throttle_enabled(false)
    , throttle_override(false)
    , throttle_driver(false)
    , throttle_timeout(false)
    , brake_cmd(0.0)
    , brake_input(0.0)
    , brake_state(0.0)
    , brake_torq_cmd(0.0)
    , brake_torq_input(0.0)
    , brake_torq_state(0.0)
    , brake_boo_output(false)
    , brake_enabled(false)
    , brake_override(false)
    , brake_driver(false)
    , brake_timeout(false)
    , steer_cmd(0.0)
    , steer_state(0.0)
    , steer_torque(0.0)
    , steer_enabled(false)
    , steer_override(false)
    , steer_timeout(false)
    , gear_pos(0)
    , wheel_v_front_left(0.0)
    , wheel_v_front_right(0.0)
    , wheel_v_rear_left(0.0)
    , wheel_v_rear_right(0.0)  {
    }
  VehicleState_(const ContainerAllocator& _alloc)
    : timestamp(0.0)
    , RTK_state_string(_alloc)
    , RTK_seq_num(0)
    , RTK_timestamp_sec(0)
    , RTK_timestamp_nsec(0)
    , RTK_gps_status(0)
    , RTK_gps_service(0)
    , RTK_gps_longitude(0.0)
    , RTK_gps_latitude(0.0)
    , RTK_gps_altitude(0.0)
    , RTK_gps_UTM_x(0.0)
    , RTK_gps_UTM_y(0.0)
    , RTK_gps_UTM_z(0.0)
    , RTK_imu_quaternion_x(0.0)
    , RTK_imu_quaternion_y(0.0)
    , RTK_imu_quaternion_z(0.0)
    , RTK_imu_quaternion_w(0.0)
    , RTK_heading(0.0)
    , RTK_attitude(0.0)
    , RTK_bank(0.0)
    , RTK_linear_ENU_vx(0.0)
    , RTK_linear_ENU_vy(0.0)
    , RTK_linear_ENU_vz(0.0)
    , RTK_gps_twist_linear_vx(0.0)
    , RTK_gps_twist_linear_vy(0.0)
    , RTK_gps_twist_linear_vz(0.0)
    , RTK_imu_linear_acc_x(0.0)
    , RTK_imu_linear_acc_y(0.0)
    , RTK_imu_linear_acc_z(0.0)
    , RTK_gps_twist_angular_vx(0.0)
    , RTK_gps_twist_angular_vy(0.0)
    , RTK_gps_twist_angular_vz(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , speed_x(0.0)
    , speed_y(0.0)
    , speed_z(0.0)
    , acc_x(0.0)
    , acc_y(0.0)
    , acc_z(0.0)
    , heading(0.0)
    , yaw_rate(0.0)
    , by_wire_enabled(false)
    , throttle_cmd(0.0)
    , throttle_input(0.0)
    , throttle_state(0.0)
    , throttle_enabled(false)
    , throttle_override(false)
    , throttle_driver(false)
    , throttle_timeout(false)
    , brake_cmd(0.0)
    , brake_input(0.0)
    , brake_state(0.0)
    , brake_torq_cmd(0.0)
    , brake_torq_input(0.0)
    , brake_torq_state(0.0)
    , brake_boo_output(false)
    , brake_enabled(false)
    , brake_override(false)
    , brake_driver(false)
    , brake_timeout(false)
    , steer_cmd(0.0)
    , steer_state(0.0)
    , steer_torque(0.0)
    , steer_enabled(false)
    , steer_override(false)
    , steer_timeout(false)
    , gear_pos(0)
    , wheel_v_front_left(0.0)
    , wheel_v_front_right(0.0)
    , wheel_v_rear_left(0.0)
    , wheel_v_rear_right(0.0)  {
  (void)_alloc;
    }



   typedef double _timestamp_type;
  _timestamp_type timestamp;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _RTK_state_string_type;
  _RTK_state_string_type RTK_state_string;

   typedef int64_t _RTK_seq_num_type;
  _RTK_seq_num_type RTK_seq_num;

   typedef int64_t _RTK_timestamp_sec_type;
  _RTK_timestamp_sec_type RTK_timestamp_sec;

   typedef int64_t _RTK_timestamp_nsec_type;
  _RTK_timestamp_nsec_type RTK_timestamp_nsec;

   typedef int16_t _RTK_gps_status_type;
  _RTK_gps_status_type RTK_gps_status;

   typedef int16_t _RTK_gps_service_type;
  _RTK_gps_service_type RTK_gps_service;

   typedef double _RTK_gps_longitude_type;
  _RTK_gps_longitude_type RTK_gps_longitude;

   typedef double _RTK_gps_latitude_type;
  _RTK_gps_latitude_type RTK_gps_latitude;

   typedef double _RTK_gps_altitude_type;
  _RTK_gps_altitude_type RTK_gps_altitude;

   typedef double _RTK_gps_UTM_x_type;
  _RTK_gps_UTM_x_type RTK_gps_UTM_x;

   typedef double _RTK_gps_UTM_y_type;
  _RTK_gps_UTM_y_type RTK_gps_UTM_y;

   typedef double _RTK_gps_UTM_z_type;
  _RTK_gps_UTM_z_type RTK_gps_UTM_z;

   typedef double _RTK_imu_quaternion_x_type;
  _RTK_imu_quaternion_x_type RTK_imu_quaternion_x;

   typedef double _RTK_imu_quaternion_y_type;
  _RTK_imu_quaternion_y_type RTK_imu_quaternion_y;

   typedef double _RTK_imu_quaternion_z_type;
  _RTK_imu_quaternion_z_type RTK_imu_quaternion_z;

   typedef double _RTK_imu_quaternion_w_type;
  _RTK_imu_quaternion_w_type RTK_imu_quaternion_w;

   typedef double _RTK_heading_type;
  _RTK_heading_type RTK_heading;

   typedef double _RTK_attitude_type;
  _RTK_attitude_type RTK_attitude;

   typedef double _RTK_bank_type;
  _RTK_bank_type RTK_bank;

   typedef double _RTK_linear_ENU_vx_type;
  _RTK_linear_ENU_vx_type RTK_linear_ENU_vx;

   typedef double _RTK_linear_ENU_vy_type;
  _RTK_linear_ENU_vy_type RTK_linear_ENU_vy;

   typedef double _RTK_linear_ENU_vz_type;
  _RTK_linear_ENU_vz_type RTK_linear_ENU_vz;

   typedef double _RTK_gps_twist_linear_vx_type;
  _RTK_gps_twist_linear_vx_type RTK_gps_twist_linear_vx;

   typedef double _RTK_gps_twist_linear_vy_type;
  _RTK_gps_twist_linear_vy_type RTK_gps_twist_linear_vy;

   typedef double _RTK_gps_twist_linear_vz_type;
  _RTK_gps_twist_linear_vz_type RTK_gps_twist_linear_vz;

   typedef double _RTK_imu_linear_acc_x_type;
  _RTK_imu_linear_acc_x_type RTK_imu_linear_acc_x;

   typedef double _RTK_imu_linear_acc_y_type;
  _RTK_imu_linear_acc_y_type RTK_imu_linear_acc_y;

   typedef double _RTK_imu_linear_acc_z_type;
  _RTK_imu_linear_acc_z_type RTK_imu_linear_acc_z;

   typedef double _RTK_gps_twist_angular_vx_type;
  _RTK_gps_twist_angular_vx_type RTK_gps_twist_angular_vx;

   typedef double _RTK_gps_twist_angular_vy_type;
  _RTK_gps_twist_angular_vy_type RTK_gps_twist_angular_vy;

   typedef double _RTK_gps_twist_angular_vz_type;
  _RTK_gps_twist_angular_vz_type RTK_gps_twist_angular_vz;

   typedef double _x_type;
  _x_type x;

   typedef double _y_type;
  _y_type y;

   typedef double _z_type;
  _z_type z;

   typedef double _speed_x_type;
  _speed_x_type speed_x;

   typedef double _speed_y_type;
  _speed_y_type speed_y;

   typedef double _speed_z_type;
  _speed_z_type speed_z;

   typedef double _acc_x_type;
  _acc_x_type acc_x;

   typedef double _acc_y_type;
  _acc_y_type acc_y;

   typedef double _acc_z_type;
  _acc_z_type acc_z;

   typedef double _heading_type;
  _heading_type heading;

   typedef double _yaw_rate_type;
  _yaw_rate_type yaw_rate;

   typedef uint8_t _by_wire_enabled_type;
  _by_wire_enabled_type by_wire_enabled;

   typedef double _throttle_cmd_type;
  _throttle_cmd_type throttle_cmd;

   typedef double _throttle_input_type;
  _throttle_input_type throttle_input;

   typedef double _throttle_state_type;
  _throttle_state_type throttle_state;

   typedef uint8_t _throttle_enabled_type;
  _throttle_enabled_type throttle_enabled;

   typedef uint8_t _throttle_override_type;
  _throttle_override_type throttle_override;

   typedef uint8_t _throttle_driver_type;
  _throttle_driver_type throttle_driver;

   typedef uint8_t _throttle_timeout_type;
  _throttle_timeout_type throttle_timeout;

   typedef double _brake_cmd_type;
  _brake_cmd_type brake_cmd;

   typedef double _brake_input_type;
  _brake_input_type brake_input;

   typedef double _brake_state_type;
  _brake_state_type brake_state;

   typedef double _brake_torq_cmd_type;
  _brake_torq_cmd_type brake_torq_cmd;

   typedef double _brake_torq_input_type;
  _brake_torq_input_type brake_torq_input;

   typedef double _brake_torq_state_type;
  _brake_torq_state_type brake_torq_state;

   typedef uint8_t _brake_boo_output_type;
  _brake_boo_output_type brake_boo_output;

   typedef uint8_t _brake_enabled_type;
  _brake_enabled_type brake_enabled;

   typedef uint8_t _brake_override_type;
  _brake_override_type brake_override;

   typedef uint8_t _brake_driver_type;
  _brake_driver_type brake_driver;

   typedef uint8_t _brake_timeout_type;
  _brake_timeout_type brake_timeout;

   typedef double _steer_cmd_type;
  _steer_cmd_type steer_cmd;

   typedef double _steer_state_type;
  _steer_state_type steer_state;

   typedef double _steer_torque_type;
  _steer_torque_type steer_torque;

   typedef uint8_t _steer_enabled_type;
  _steer_enabled_type steer_enabled;

   typedef uint8_t _steer_override_type;
  _steer_override_type steer_override;

   typedef uint8_t _steer_timeout_type;
  _steer_timeout_type steer_timeout;

   typedef int16_t _gear_pos_type;
  _gear_pos_type gear_pos;

   typedef double _wheel_v_front_left_type;
  _wheel_v_front_left_type wheel_v_front_left;

   typedef double _wheel_v_front_right_type;
  _wheel_v_front_right_type wheel_v_front_right;

   typedef double _wheel_v_rear_left_type;
  _wheel_v_rear_left_type wheel_v_rear_left;

   typedef double _wheel_v_rear_right_type;
  _wheel_v_rear_right_type wheel_v_rear_right;





  typedef boost::shared_ptr< ::mcity_msg::VehicleState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mcity_msg::VehicleState_<ContainerAllocator> const> ConstPtr;

}; // struct VehicleState_

typedef ::mcity_msg::VehicleState_<std::allocator<void> > VehicleState;

typedef boost::shared_ptr< ::mcity_msg::VehicleState > VehicleStatePtr;
typedef boost::shared_ptr< ::mcity_msg::VehicleState const> VehicleStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mcity_msg::VehicleState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mcity_msg::VehicleState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mcity_msg::VehicleState_<ContainerAllocator1> & lhs, const ::mcity_msg::VehicleState_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.RTK_state_string == rhs.RTK_state_string &&
    lhs.RTK_seq_num == rhs.RTK_seq_num &&
    lhs.RTK_timestamp_sec == rhs.RTK_timestamp_sec &&
    lhs.RTK_timestamp_nsec == rhs.RTK_timestamp_nsec &&
    lhs.RTK_gps_status == rhs.RTK_gps_status &&
    lhs.RTK_gps_service == rhs.RTK_gps_service &&
    lhs.RTK_gps_longitude == rhs.RTK_gps_longitude &&
    lhs.RTK_gps_latitude == rhs.RTK_gps_latitude &&
    lhs.RTK_gps_altitude == rhs.RTK_gps_altitude &&
    lhs.RTK_gps_UTM_x == rhs.RTK_gps_UTM_x &&
    lhs.RTK_gps_UTM_y == rhs.RTK_gps_UTM_y &&
    lhs.RTK_gps_UTM_z == rhs.RTK_gps_UTM_z &&
    lhs.RTK_imu_quaternion_x == rhs.RTK_imu_quaternion_x &&
    lhs.RTK_imu_quaternion_y == rhs.RTK_imu_quaternion_y &&
    lhs.RTK_imu_quaternion_z == rhs.RTK_imu_quaternion_z &&
    lhs.RTK_imu_quaternion_w == rhs.RTK_imu_quaternion_w &&
    lhs.RTK_heading == rhs.RTK_heading &&
    lhs.RTK_attitude == rhs.RTK_attitude &&
    lhs.RTK_bank == rhs.RTK_bank &&
    lhs.RTK_linear_ENU_vx == rhs.RTK_linear_ENU_vx &&
    lhs.RTK_linear_ENU_vy == rhs.RTK_linear_ENU_vy &&
    lhs.RTK_linear_ENU_vz == rhs.RTK_linear_ENU_vz &&
    lhs.RTK_gps_twist_linear_vx == rhs.RTK_gps_twist_linear_vx &&
    lhs.RTK_gps_twist_linear_vy == rhs.RTK_gps_twist_linear_vy &&
    lhs.RTK_gps_twist_linear_vz == rhs.RTK_gps_twist_linear_vz &&
    lhs.RTK_imu_linear_acc_x == rhs.RTK_imu_linear_acc_x &&
    lhs.RTK_imu_linear_acc_y == rhs.RTK_imu_linear_acc_y &&
    lhs.RTK_imu_linear_acc_z == rhs.RTK_imu_linear_acc_z &&
    lhs.RTK_gps_twist_angular_vx == rhs.RTK_gps_twist_angular_vx &&
    lhs.RTK_gps_twist_angular_vy == rhs.RTK_gps_twist_angular_vy &&
    lhs.RTK_gps_twist_angular_vz == rhs.RTK_gps_twist_angular_vz &&
    lhs.x == rhs.x &&
    lhs.y == rhs.y &&
    lhs.z == rhs.z &&
    lhs.speed_x == rhs.speed_x &&
    lhs.speed_y == rhs.speed_y &&
    lhs.speed_z == rhs.speed_z &&
    lhs.acc_x == rhs.acc_x &&
    lhs.acc_y == rhs.acc_y &&
    lhs.acc_z == rhs.acc_z &&
    lhs.heading == rhs.heading &&
    lhs.yaw_rate == rhs.yaw_rate &&
    lhs.by_wire_enabled == rhs.by_wire_enabled &&
    lhs.throttle_cmd == rhs.throttle_cmd &&
    lhs.throttle_input == rhs.throttle_input &&
    lhs.throttle_state == rhs.throttle_state &&
    lhs.throttle_enabled == rhs.throttle_enabled &&
    lhs.throttle_override == rhs.throttle_override &&
    lhs.throttle_driver == rhs.throttle_driver &&
    lhs.throttle_timeout == rhs.throttle_timeout &&
    lhs.brake_cmd == rhs.brake_cmd &&
    lhs.brake_input == rhs.brake_input &&
    lhs.brake_state == rhs.brake_state &&
    lhs.brake_torq_cmd == rhs.brake_torq_cmd &&
    lhs.brake_torq_input == rhs.brake_torq_input &&
    lhs.brake_torq_state == rhs.brake_torq_state &&
    lhs.brake_boo_output == rhs.brake_boo_output &&
    lhs.brake_enabled == rhs.brake_enabled &&
    lhs.brake_override == rhs.brake_override &&
    lhs.brake_driver == rhs.brake_driver &&
    lhs.brake_timeout == rhs.brake_timeout &&
    lhs.steer_cmd == rhs.steer_cmd &&
    lhs.steer_state == rhs.steer_state &&
    lhs.steer_torque == rhs.steer_torque &&
    lhs.steer_enabled == rhs.steer_enabled &&
    lhs.steer_override == rhs.steer_override &&
    lhs.steer_timeout == rhs.steer_timeout &&
    lhs.gear_pos == rhs.gear_pos &&
    lhs.wheel_v_front_left == rhs.wheel_v_front_left &&
    lhs.wheel_v_front_right == rhs.wheel_v_front_right &&
    lhs.wheel_v_rear_left == rhs.wheel_v_rear_left &&
    lhs.wheel_v_rear_right == rhs.wheel_v_rear_right;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mcity_msg::VehicleState_<ContainerAllocator1> & lhs, const ::mcity_msg::VehicleState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mcity_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mcity_msg::VehicleState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mcity_msg::VehicleState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mcity_msg::VehicleState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mcity_msg::VehicleState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mcity_msg::VehicleState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mcity_msg::VehicleState_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mcity_msg::VehicleState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4ef71996d54303151b041991d8eb5118";
  }

  static const char* value(const ::mcity_msg::VehicleState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4ef71996d5430315ULL;
  static const uint64_t static_value2 = 0x1b041991d8eb5118ULL;
};

template<class ContainerAllocator>
struct DataType< ::mcity_msg::VehicleState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mcity_msg/VehicleState";
  }

  static const char* value(const ::mcity_msg::VehicleState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mcity_msg::VehicleState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 timestamp\n"
"\n"
"#RTK state\n"
"string 	RTK_state_string\n"
"\n"
"int64   RTK_seq_num\n"
"int64   RTK_timestamp_sec\n"
"int64   RTK_timestamp_nsec\n"
"\n"
"int16   RTK_gps_status	\n"
"int16   RTK_gps_service	\n"
"\n"
"#RTK position\n"
"float64 RTK_gps_longitude\n"
"float64 RTK_gps_latitude\n"
"float64 RTK_gps_altitude\n"
"\n"
"float64 RTK_gps_UTM_x\n"
"float64 RTK_gps_UTM_y\n"
"float64 RTK_gps_UTM_z\n"
"\n"
"float64 RTK_imu_quaternion_x\n"
"float64 RTK_imu_quaternion_y\n"
"float64 RTK_imu_quaternion_z\n"
"float64 RTK_imu_quaternion_w\n"
"\n"
"float64 RTK_heading\n"
"float64 RTK_attitude\n"
"float64 RTK_bank\n"
"\n"
"#RTK ENU speed\n"
"float64 RTK_linear_ENU_vx\n"
"float64 RTK_linear_ENU_vy\n"
"float64 RTK_linear_ENU_vz\n"
"\n"
"\n"
"#RTK local speed and acc\n"
"float64 RTK_gps_twist_linear_vx\n"
"float64 RTK_gps_twist_linear_vy\n"
"float64 RTK_gps_twist_linear_vz\n"
"\n"
"float64 RTK_imu_linear_acc_x\n"
"float64 RTK_imu_linear_acc_y\n"
"float64 RTK_imu_linear_acc_z\n"
"\n"
"#RTK local angular speed\n"
"float64 RTK_gps_twist_angular_vx\n"
"float64 RTK_gps_twist_angular_vy\n"
"float64 RTK_gps_twist_angular_vz\n"
"\n"
"\n"
" \n"
"#key vehicle state\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
"\n"
"float64 speed_x\n"
"float64 speed_y\n"
"float64 speed_z\n"
"\n"
"float64 acc_x\n"
"float64 acc_y\n"
"float64 acc_z\n"
"\n"
"float64 heading\n"
"float64 yaw_rate\n"
"\n"
"#by-wire\n"
"bool 	by_wire_enabled\n"
"\n"
"float64 throttle_cmd\n"
"float64 throttle_input\n"
"float64 throttle_state\n"
"bool    throttle_enabled\n"
"bool    throttle_override\n"
"bool    throttle_driver\n"
"bool    throttle_timeout\n"
" \n"
"\n"
"float64 brake_cmd\n"
"float64 brake_input\n"
"float64 brake_state\n"
"float64 brake_torq_cmd\n"
"float64 brake_torq_input\n"
"float64 brake_torq_state\n"
"bool    brake_boo_output\n"
"bool    brake_enabled\n"
"bool    brake_override\n"
"bool    brake_driver\n"
"bool    brake_timeout\n"
"\n"
"\n"
"float64 steer_cmd\n"
"float64 steer_state\n"
"float64 steer_torque\n"
"bool    steer_enabled\n"
"bool    steer_override\n"
"bool    steer_timeout\n"
"\n"
"int16   gear_pos\n"
"\n"
"float64 wheel_v_front_left\n"
"float64 wheel_v_front_right\n"
"float64 wheel_v_rear_left\n"
"float64 wheel_v_rear_right\n"
;
  }

  static const char* value(const ::mcity_msg::VehicleState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mcity_msg::VehicleState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.RTK_state_string);
      stream.next(m.RTK_seq_num);
      stream.next(m.RTK_timestamp_sec);
      stream.next(m.RTK_timestamp_nsec);
      stream.next(m.RTK_gps_status);
      stream.next(m.RTK_gps_service);
      stream.next(m.RTK_gps_longitude);
      stream.next(m.RTK_gps_latitude);
      stream.next(m.RTK_gps_altitude);
      stream.next(m.RTK_gps_UTM_x);
      stream.next(m.RTK_gps_UTM_y);
      stream.next(m.RTK_gps_UTM_z);
      stream.next(m.RTK_imu_quaternion_x);
      stream.next(m.RTK_imu_quaternion_y);
      stream.next(m.RTK_imu_quaternion_z);
      stream.next(m.RTK_imu_quaternion_w);
      stream.next(m.RTK_heading);
      stream.next(m.RTK_attitude);
      stream.next(m.RTK_bank);
      stream.next(m.RTK_linear_ENU_vx);
      stream.next(m.RTK_linear_ENU_vy);
      stream.next(m.RTK_linear_ENU_vz);
      stream.next(m.RTK_gps_twist_linear_vx);
      stream.next(m.RTK_gps_twist_linear_vy);
      stream.next(m.RTK_gps_twist_linear_vz);
      stream.next(m.RTK_imu_linear_acc_x);
      stream.next(m.RTK_imu_linear_acc_y);
      stream.next(m.RTK_imu_linear_acc_z);
      stream.next(m.RTK_gps_twist_angular_vx);
      stream.next(m.RTK_gps_twist_angular_vy);
      stream.next(m.RTK_gps_twist_angular_vz);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.speed_x);
      stream.next(m.speed_y);
      stream.next(m.speed_z);
      stream.next(m.acc_x);
      stream.next(m.acc_y);
      stream.next(m.acc_z);
      stream.next(m.heading);
      stream.next(m.yaw_rate);
      stream.next(m.by_wire_enabled);
      stream.next(m.throttle_cmd);
      stream.next(m.throttle_input);
      stream.next(m.throttle_state);
      stream.next(m.throttle_enabled);
      stream.next(m.throttle_override);
      stream.next(m.throttle_driver);
      stream.next(m.throttle_timeout);
      stream.next(m.brake_cmd);
      stream.next(m.brake_input);
      stream.next(m.brake_state);
      stream.next(m.brake_torq_cmd);
      stream.next(m.brake_torq_input);
      stream.next(m.brake_torq_state);
      stream.next(m.brake_boo_output);
      stream.next(m.brake_enabled);
      stream.next(m.brake_override);
      stream.next(m.brake_driver);
      stream.next(m.brake_timeout);
      stream.next(m.steer_cmd);
      stream.next(m.steer_state);
      stream.next(m.steer_torque);
      stream.next(m.steer_enabled);
      stream.next(m.steer_override);
      stream.next(m.steer_timeout);
      stream.next(m.gear_pos);
      stream.next(m.wheel_v_front_left);
      stream.next(m.wheel_v_front_right);
      stream.next(m.wheel_v_rear_left);
      stream.next(m.wheel_v_rear_right);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct VehicleState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mcity_msg::VehicleState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mcity_msg::VehicleState_<ContainerAllocator>& v)
  {
    s << indent << "timestamp: ";
    Printer<double>::stream(s, indent + "  ", v.timestamp);
    s << indent << "RTK_state_string: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.RTK_state_string);
    s << indent << "RTK_seq_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_seq_num);
    s << indent << "RTK_timestamp_sec: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_timestamp_sec);
    s << indent << "RTK_timestamp_nsec: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_timestamp_nsec);
    s << indent << "RTK_gps_status: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RTK_gps_status);
    s << indent << "RTK_gps_service: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RTK_gps_service);
    s << indent << "RTK_gps_longitude: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_longitude);
    s << indent << "RTK_gps_latitude: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_latitude);
    s << indent << "RTK_gps_altitude: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_altitude);
    s << indent << "RTK_gps_UTM_x: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_UTM_x);
    s << indent << "RTK_gps_UTM_y: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_UTM_y);
    s << indent << "RTK_gps_UTM_z: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_UTM_z);
    s << indent << "RTK_imu_quaternion_x: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_quaternion_x);
    s << indent << "RTK_imu_quaternion_y: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_quaternion_y);
    s << indent << "RTK_imu_quaternion_z: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_quaternion_z);
    s << indent << "RTK_imu_quaternion_w: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_quaternion_w);
    s << indent << "RTK_heading: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_heading);
    s << indent << "RTK_attitude: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_attitude);
    s << indent << "RTK_bank: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_bank);
    s << indent << "RTK_linear_ENU_vx: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_linear_ENU_vx);
    s << indent << "RTK_linear_ENU_vy: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_linear_ENU_vy);
    s << indent << "RTK_linear_ENU_vz: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_linear_ENU_vz);
    s << indent << "RTK_gps_twist_linear_vx: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_twist_linear_vx);
    s << indent << "RTK_gps_twist_linear_vy: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_twist_linear_vy);
    s << indent << "RTK_gps_twist_linear_vz: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_twist_linear_vz);
    s << indent << "RTK_imu_linear_acc_x: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_linear_acc_x);
    s << indent << "RTK_imu_linear_acc_y: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_linear_acc_y);
    s << indent << "RTK_imu_linear_acc_z: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_imu_linear_acc_z);
    s << indent << "RTK_gps_twist_angular_vx: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_twist_angular_vx);
    s << indent << "RTK_gps_twist_angular_vy: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_twist_angular_vy);
    s << indent << "RTK_gps_twist_angular_vz: ";
    Printer<double>::stream(s, indent + "  ", v.RTK_gps_twist_angular_vz);
    s << indent << "x: ";
    Printer<double>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<double>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<double>::stream(s, indent + "  ", v.z);
    s << indent << "speed_x: ";
    Printer<double>::stream(s, indent + "  ", v.speed_x);
    s << indent << "speed_y: ";
    Printer<double>::stream(s, indent + "  ", v.speed_y);
    s << indent << "speed_z: ";
    Printer<double>::stream(s, indent + "  ", v.speed_z);
    s << indent << "acc_x: ";
    Printer<double>::stream(s, indent + "  ", v.acc_x);
    s << indent << "acc_y: ";
    Printer<double>::stream(s, indent + "  ", v.acc_y);
    s << indent << "acc_z: ";
    Printer<double>::stream(s, indent + "  ", v.acc_z);
    s << indent << "heading: ";
    Printer<double>::stream(s, indent + "  ", v.heading);
    s << indent << "yaw_rate: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_rate);
    s << indent << "by_wire_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.by_wire_enabled);
    s << indent << "throttle_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.throttle_cmd);
    s << indent << "throttle_input: ";
    Printer<double>::stream(s, indent + "  ", v.throttle_input);
    s << indent << "throttle_state: ";
    Printer<double>::stream(s, indent + "  ", v.throttle_state);
    s << indent << "throttle_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_enabled);
    s << indent << "throttle_override: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_override);
    s << indent << "throttle_driver: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_driver);
    s << indent << "throttle_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_timeout);
    s << indent << "brake_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.brake_cmd);
    s << indent << "brake_input: ";
    Printer<double>::stream(s, indent + "  ", v.brake_input);
    s << indent << "brake_state: ";
    Printer<double>::stream(s, indent + "  ", v.brake_state);
    s << indent << "brake_torq_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.brake_torq_cmd);
    s << indent << "brake_torq_input: ";
    Printer<double>::stream(s, indent + "  ", v.brake_torq_input);
    s << indent << "brake_torq_state: ";
    Printer<double>::stream(s, indent + "  ", v.brake_torq_state);
    s << indent << "brake_boo_output: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_boo_output);
    s << indent << "brake_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_enabled);
    s << indent << "brake_override: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_override);
    s << indent << "brake_driver: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_driver);
    s << indent << "brake_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_timeout);
    s << indent << "steer_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.steer_cmd);
    s << indent << "steer_state: ";
    Printer<double>::stream(s, indent + "  ", v.steer_state);
    s << indent << "steer_torque: ";
    Printer<double>::stream(s, indent + "  ", v.steer_torque);
    s << indent << "steer_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.steer_enabled);
    s << indent << "steer_override: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.steer_override);
    s << indent << "steer_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.steer_timeout);
    s << indent << "gear_pos: ";
    Printer<int16_t>::stream(s, indent + "  ", v.gear_pos);
    s << indent << "wheel_v_front_left: ";
    Printer<double>::stream(s, indent + "  ", v.wheel_v_front_left);
    s << indent << "wheel_v_front_right: ";
    Printer<double>::stream(s, indent + "  ", v.wheel_v_front_right);
    s << indent << "wheel_v_rear_left: ";
    Printer<double>::stream(s, indent + "  ", v.wheel_v_rear_left);
    s << indent << "wheel_v_rear_right: ";
    Printer<double>::stream(s, indent + "  ", v.wheel_v_rear_right);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MCITY_MSG_MESSAGE_VEHICLESTATE_H
