// Generated by gencpp from file mcity_msg/SensorCheck.msg
// DO NOT EDIT!


#ifndef MCITY_MSG_MESSAGE_SENSORCHECK_H
#define MCITY_MSG_MESSAGE_SENSORCHECK_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mcity_msg
{
template <class ContainerAllocator>
struct SensorCheck_
{
  typedef SensorCheck_<ContainerAllocator> Type;

  SensorCheck_()
    : timestamp(0.0)
    , RTK_timestamp_sec(0)
    , RTK_timestamp_nsec(0)
    , RTK_keep_count(0)
    , RTK_seq_num(0)
    , RTK_gps_status(0)
    , RTK_gps_service(0)
    , Mobileye_keep_count(0)
    , Mobileye_lanes_num(0)
    , DSRC_bsm_keep_count(0)
    , DSRC_bsm_num(0)
    , DSRC_spat_keep_count(0)
    , DSRC_spat_num(0)
    , Ibeo_points_keep_count(0)
    , Ibeo_points_num(0)
    , Ibeo_objects_keep_count(0)
    , Ibeo_objests_num(0)
    , Velodyne_points_keep_count(0)
    , Velodyne_points_num(0)
    , throttle_enabled(false)
    , throttle_override(false)
    , throttle_driver(false)
    , throttle_timeout(false)
    , brake_enabled(false)
    , brake_override(false)
    , brake_driver(false)
    , brake_timeout(false)
    , steer_enabled(false)
    , steer_override(false)
    , steer_timeout(false)  {
    }
  SensorCheck_(const ContainerAllocator& _alloc)
    : timestamp(0.0)
    , RTK_timestamp_sec(0)
    , RTK_timestamp_nsec(0)
    , RTK_keep_count(0)
    , RTK_seq_num(0)
    , RTK_gps_status(0)
    , RTK_gps_service(0)
    , Mobileye_keep_count(0)
    , Mobileye_lanes_num(0)
    , DSRC_bsm_keep_count(0)
    , DSRC_bsm_num(0)
    , DSRC_spat_keep_count(0)
    , DSRC_spat_num(0)
    , Ibeo_points_keep_count(0)
    , Ibeo_points_num(0)
    , Ibeo_objects_keep_count(0)
    , Ibeo_objests_num(0)
    , Velodyne_points_keep_count(0)
    , Velodyne_points_num(0)
    , throttle_enabled(false)
    , throttle_override(false)
    , throttle_driver(false)
    , throttle_timeout(false)
    , brake_enabled(false)
    , brake_override(false)
    , brake_driver(false)
    , brake_timeout(false)
    , steer_enabled(false)
    , steer_override(false)
    , steer_timeout(false)  {
  (void)_alloc;
    }



   typedef double _timestamp_type;
  _timestamp_type timestamp;

   typedef int64_t _RTK_timestamp_sec_type;
  _RTK_timestamp_sec_type RTK_timestamp_sec;

   typedef int64_t _RTK_timestamp_nsec_type;
  _RTK_timestamp_nsec_type RTK_timestamp_nsec;

   typedef int64_t _RTK_keep_count_type;
  _RTK_keep_count_type RTK_keep_count;

   typedef int64_t _RTK_seq_num_type;
  _RTK_seq_num_type RTK_seq_num;

   typedef int16_t _RTK_gps_status_type;
  _RTK_gps_status_type RTK_gps_status;

   typedef int16_t _RTK_gps_service_type;
  _RTK_gps_service_type RTK_gps_service;

   typedef int64_t _Mobileye_keep_count_type;
  _Mobileye_keep_count_type Mobileye_keep_count;

   typedef int16_t _Mobileye_lanes_num_type;
  _Mobileye_lanes_num_type Mobileye_lanes_num;

   typedef int64_t _DSRC_bsm_keep_count_type;
  _DSRC_bsm_keep_count_type DSRC_bsm_keep_count;

   typedef int64_t _DSRC_bsm_num_type;
  _DSRC_bsm_num_type DSRC_bsm_num;

   typedef int64_t _DSRC_spat_keep_count_type;
  _DSRC_spat_keep_count_type DSRC_spat_keep_count;

   typedef int64_t _DSRC_spat_num_type;
  _DSRC_spat_num_type DSRC_spat_num;

   typedef int64_t _Ibeo_points_keep_count_type;
  _Ibeo_points_keep_count_type Ibeo_points_keep_count;

   typedef int64_t _Ibeo_points_num_type;
  _Ibeo_points_num_type Ibeo_points_num;

   typedef int64_t _Ibeo_objects_keep_count_type;
  _Ibeo_objects_keep_count_type Ibeo_objects_keep_count;

   typedef int64_t _Ibeo_objests_num_type;
  _Ibeo_objests_num_type Ibeo_objests_num;

   typedef int64_t _Velodyne_points_keep_count_type;
  _Velodyne_points_keep_count_type Velodyne_points_keep_count;

   typedef int64_t _Velodyne_points_num_type;
  _Velodyne_points_num_type Velodyne_points_num;

   typedef uint8_t _throttle_enabled_type;
  _throttle_enabled_type throttle_enabled;

   typedef uint8_t _throttle_override_type;
  _throttle_override_type throttle_override;

   typedef uint8_t _throttle_driver_type;
  _throttle_driver_type throttle_driver;

   typedef uint8_t _throttle_timeout_type;
  _throttle_timeout_type throttle_timeout;

   typedef uint8_t _brake_enabled_type;
  _brake_enabled_type brake_enabled;

   typedef uint8_t _brake_override_type;
  _brake_override_type brake_override;

   typedef uint8_t _brake_driver_type;
  _brake_driver_type brake_driver;

   typedef uint8_t _brake_timeout_type;
  _brake_timeout_type brake_timeout;

   typedef uint8_t _steer_enabled_type;
  _steer_enabled_type steer_enabled;

   typedef uint8_t _steer_override_type;
  _steer_override_type steer_override;

   typedef uint8_t _steer_timeout_type;
  _steer_timeout_type steer_timeout;





  typedef boost::shared_ptr< ::mcity_msg::SensorCheck_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mcity_msg::SensorCheck_<ContainerAllocator> const> ConstPtr;

}; // struct SensorCheck_

typedef ::mcity_msg::SensorCheck_<std::allocator<void> > SensorCheck;

typedef boost::shared_ptr< ::mcity_msg::SensorCheck > SensorCheckPtr;
typedef boost::shared_ptr< ::mcity_msg::SensorCheck const> SensorCheckConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mcity_msg::SensorCheck_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mcity_msg::SensorCheck_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mcity_msg::SensorCheck_<ContainerAllocator1> & lhs, const ::mcity_msg::SensorCheck_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.RTK_timestamp_sec == rhs.RTK_timestamp_sec &&
    lhs.RTK_timestamp_nsec == rhs.RTK_timestamp_nsec &&
    lhs.RTK_keep_count == rhs.RTK_keep_count &&
    lhs.RTK_seq_num == rhs.RTK_seq_num &&
    lhs.RTK_gps_status == rhs.RTK_gps_status &&
    lhs.RTK_gps_service == rhs.RTK_gps_service &&
    lhs.Mobileye_keep_count == rhs.Mobileye_keep_count &&
    lhs.Mobileye_lanes_num == rhs.Mobileye_lanes_num &&
    lhs.DSRC_bsm_keep_count == rhs.DSRC_bsm_keep_count &&
    lhs.DSRC_bsm_num == rhs.DSRC_bsm_num &&
    lhs.DSRC_spat_keep_count == rhs.DSRC_spat_keep_count &&
    lhs.DSRC_spat_num == rhs.DSRC_spat_num &&
    lhs.Ibeo_points_keep_count == rhs.Ibeo_points_keep_count &&
    lhs.Ibeo_points_num == rhs.Ibeo_points_num &&
    lhs.Ibeo_objects_keep_count == rhs.Ibeo_objects_keep_count &&
    lhs.Ibeo_objests_num == rhs.Ibeo_objests_num &&
    lhs.Velodyne_points_keep_count == rhs.Velodyne_points_keep_count &&
    lhs.Velodyne_points_num == rhs.Velodyne_points_num &&
    lhs.throttle_enabled == rhs.throttle_enabled &&
    lhs.throttle_override == rhs.throttle_override &&
    lhs.throttle_driver == rhs.throttle_driver &&
    lhs.throttle_timeout == rhs.throttle_timeout &&
    lhs.brake_enabled == rhs.brake_enabled &&
    lhs.brake_override == rhs.brake_override &&
    lhs.brake_driver == rhs.brake_driver &&
    lhs.brake_timeout == rhs.brake_timeout &&
    lhs.steer_enabled == rhs.steer_enabled &&
    lhs.steer_override == rhs.steer_override &&
    lhs.steer_timeout == rhs.steer_timeout;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mcity_msg::SensorCheck_<ContainerAllocator1> & lhs, const ::mcity_msg::SensorCheck_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mcity_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mcity_msg::SensorCheck_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mcity_msg::SensorCheck_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mcity_msg::SensorCheck_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mcity_msg::SensorCheck_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mcity_msg::SensorCheck_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mcity_msg::SensorCheck_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mcity_msg::SensorCheck_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d19ac1700cbcb00cc0b794ff0733ff04";
  }

  static const char* value(const ::mcity_msg::SensorCheck_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd19ac1700cbcb00cULL;
  static const uint64_t static_value2 = 0xc0b794ff0733ff04ULL;
};

template<class ContainerAllocator>
struct DataType< ::mcity_msg::SensorCheck_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mcity_msg/SensorCheck";
  }

  static const char* value(const ::mcity_msg::SensorCheck_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mcity_msg::SensorCheck_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 timestamp\n"
"int64   RTK_timestamp_sec\n"
"int64   RTK_timestamp_nsec\n"
"\n"
"int64   RTK_keep_count\n"
"int64   RTK_seq_num\n"
"int16   RTK_gps_status	\n"
"int16   RTK_gps_service\n"
"\n"
"int64   Mobileye_keep_count\n"
"int16   Mobileye_lanes_num \n"
"\n"
"int64   DSRC_bsm_keep_count\n"
"int64 	DSRC_bsm_num\n"
"int64   DSRC_spat_keep_count\n"
"int64 	DSRC_spat_num\n"
"\n"
"int64   Ibeo_points_keep_count\n"
"int64 	Ibeo_points_num\n"
"int64   Ibeo_objects_keep_count\n"
"int64 	Ibeo_objests_num\n"
"\n"
"int64   Velodyne_points_keep_count\n"
"int64 	Velodyne_points_num\n"
" \n"
"bool   throttle_enabled\n"
"bool   throttle_override\n"
"bool   throttle_driver\n"
"bool   throttle_timeout\n"
"\n"
"bool   brake_enabled\n"
"bool   brake_override\n"
"bool   brake_driver\n"
"bool   brake_timeout\n"
"\n"
"bool   steer_enabled\n"
"bool   steer_override\n"
"bool   steer_timeout\n"
"\n"
;
  }

  static const char* value(const ::mcity_msg::SensorCheck_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mcity_msg::SensorCheck_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.RTK_timestamp_sec);
      stream.next(m.RTK_timestamp_nsec);
      stream.next(m.RTK_keep_count);
      stream.next(m.RTK_seq_num);
      stream.next(m.RTK_gps_status);
      stream.next(m.RTK_gps_service);
      stream.next(m.Mobileye_keep_count);
      stream.next(m.Mobileye_lanes_num);
      stream.next(m.DSRC_bsm_keep_count);
      stream.next(m.DSRC_bsm_num);
      stream.next(m.DSRC_spat_keep_count);
      stream.next(m.DSRC_spat_num);
      stream.next(m.Ibeo_points_keep_count);
      stream.next(m.Ibeo_points_num);
      stream.next(m.Ibeo_objects_keep_count);
      stream.next(m.Ibeo_objests_num);
      stream.next(m.Velodyne_points_keep_count);
      stream.next(m.Velodyne_points_num);
      stream.next(m.throttle_enabled);
      stream.next(m.throttle_override);
      stream.next(m.throttle_driver);
      stream.next(m.throttle_timeout);
      stream.next(m.brake_enabled);
      stream.next(m.brake_override);
      stream.next(m.brake_driver);
      stream.next(m.brake_timeout);
      stream.next(m.steer_enabled);
      stream.next(m.steer_override);
      stream.next(m.steer_timeout);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SensorCheck_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mcity_msg::SensorCheck_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mcity_msg::SensorCheck_<ContainerAllocator>& v)
  {
    s << indent << "timestamp: ";
    Printer<double>::stream(s, indent + "  ", v.timestamp);
    s << indent << "RTK_timestamp_sec: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_timestamp_sec);
    s << indent << "RTK_timestamp_nsec: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_timestamp_nsec);
    s << indent << "RTK_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_keep_count);
    s << indent << "RTK_seq_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.RTK_seq_num);
    s << indent << "RTK_gps_status: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RTK_gps_status);
    s << indent << "RTK_gps_service: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RTK_gps_service);
    s << indent << "Mobileye_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Mobileye_keep_count);
    s << indent << "Mobileye_lanes_num: ";
    Printer<int16_t>::stream(s, indent + "  ", v.Mobileye_lanes_num);
    s << indent << "DSRC_bsm_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.DSRC_bsm_keep_count);
    s << indent << "DSRC_bsm_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.DSRC_bsm_num);
    s << indent << "DSRC_spat_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.DSRC_spat_keep_count);
    s << indent << "DSRC_spat_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.DSRC_spat_num);
    s << indent << "Ibeo_points_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Ibeo_points_keep_count);
    s << indent << "Ibeo_points_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Ibeo_points_num);
    s << indent << "Ibeo_objects_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Ibeo_objects_keep_count);
    s << indent << "Ibeo_objests_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Ibeo_objests_num);
    s << indent << "Velodyne_points_keep_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Velodyne_points_keep_count);
    s << indent << "Velodyne_points_num: ";
    Printer<int64_t>::stream(s, indent + "  ", v.Velodyne_points_num);
    s << indent << "throttle_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_enabled);
    s << indent << "throttle_override: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_override);
    s << indent << "throttle_driver: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_driver);
    s << indent << "throttle_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle_timeout);
    s << indent << "brake_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_enabled);
    s << indent << "brake_override: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_override);
    s << indent << "brake_driver: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_driver);
    s << indent << "brake_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_timeout);
    s << indent << "steer_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.steer_enabled);
    s << indent << "steer_override: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.steer_override);
    s << indent << "steer_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.steer_timeout);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MCITY_MSG_MESSAGE_SENSORCHECK_H
